<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>L1 vs L2 Regularization: From Raw Data to Geometry</title>
  <style>
    :root {
      --bg: #0b0c10;
      --panel: #11131a;
      --ink: #e8eaf0;
      --muted: #8892b0;
      --line: #2a2f3d;
      --accent: #64ffda;
      --l2: #a78bfa;
      --l1: #fcd34d;
      --loss: #60a5fa;
      --red: #f87171;
      --green: #4ade80;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: var(--bg);
      color: var(--ink);
      font: 14px/1.5 system-ui, -apple-system, sans-serif;
      min-height: 100vh;
    }
    
    /* Navigation */
    nav {
      position: sticky;
      top: 0;
      background: rgba(11,12,16,0.95);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--line);
      padding: 10px 20px;
      z-index: 100;
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: center;
    }
    nav a {
      color: var(--muted);
      text-decoration: none;
      font-size: 12px;
      font-weight: 500;
      padding: 6px 12px;
      border-radius: 6px;
      border: 1px solid transparent;
      transition: all 0.2s;
    }
    nav a:hover {
      color: var(--accent);
      border-color: var(--accent);
      background: rgba(100,255,218,0.1);
    }
    nav a.step { background: rgba(255,255,255,0.05); }
    
    /* Header */
    header {
      text-align: center;
      padding: 40px 20px 30px;
      max-width: 900px;
      margin: 0 auto;
    }
    h1 {
      font-size: 28px;
      font-weight: 700;
      margin-bottom: 12px;
      background: linear-gradient(135deg, var(--l2), var(--accent), var(--l1));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .subtitle { color: var(--muted); font-size: 16px; }
    
    /* Sections */
    section {
      max-width: 1300px;
      margin: 0 auto;
      padding: 30px 20px 50px;
      scroll-margin-top: 60px;
    }
    .section-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 20px;
    }
    .step-badge {
      background: linear-gradient(135deg, var(--l2), var(--l1));
      color: #000;
      font-weight: 700;
      font-size: 12px;
      padding: 6px 14px;
      border-radius: 20px;
    }
    h2 { font-size: 20px; font-weight: 600; }
    
    /* Cards */
    .card {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 12px;
      overflow: hidden;
    }
    .card-header {
      padding: 12px 16px;
      border-bottom: 1px solid var(--line);
      font-weight: 600;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .card-body { padding: 16px; }
    
    /* Grid layouts */
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }
    @media (max-width: 900px) {
      .grid-2, .grid-3 { grid-template-columns: 1fr; }
    }
    
    /* Tables */
    table { width: 100%; border-collapse: collapse; font-size: 12px; }
    th, td { padding: 8px 10px; border-bottom: 1px solid var(--line); text-align: right; }
    th { color: var(--muted); font-weight: 600; text-transform: uppercase; font-size: 10px; letter-spacing: 0.5px; }
    td:first-child, th:first-child { text-align: left; }
    .mono { font-family: ui-monospace, 'SF Mono', Consolas, monospace; }
    
    /* Canvas */
    .canvas-wrap {
      background: #0a0b0f;
      border-radius: 10px;
      border: 1px solid var(--line);
      overflow: hidden;
    }
    canvas { display: block; width: 100%; height: auto; }
    
    /* Controls */
    .controls { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 12px; }
    .control-group {
      flex: 1;
      min-width: 150px;
      background: rgba(0,0,0,0.3);
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px 12px;
    }
    .control-group label { display: block; font-size: 11px; color: var(--muted); margin-bottom: 6px; }
    input[type="range"] {
      width: 100%;
      height: 6px;
      -webkit-appearance: none;
      background: rgba(255,255,255,0.1);
      border-radius: 3px;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
    }
    .control-value { font-family: monospace; font-size: 12px; margin-top: 4px; color: var(--accent); }
    select {
      width: 100%;
      background: #0a0b0f;
      color: var(--ink);
      border: 1px solid var(--line);
      border-radius: 6px;
      padding: 8px 10px;
      font-size: 13px;
    }
    
    /* Buttons */
    .btn-group { display: flex; gap: 8px; flex-wrap: wrap; }
    button {
      font-family: inherit;
      font-size: 12px;
      font-weight: 600;
      padding: 8px 14px;
      border: 1px solid var(--line);
      border-radius: 8px;
      background: rgba(255,255,255,0.05);
      color: var(--ink);
      cursor: pointer;
      transition: all 0.2s;
    }
    button:hover { background: rgba(255,255,255,0.1); border-color: var(--accent); }
    button.active { background: rgba(100,255,218,0.15); border-color: var(--accent); color: var(--accent); }
    button.l2 { border-color: var(--l2); color: var(--l2); }
    button.l1 { border-color: var(--l1); color: var(--l1); }
    
    /* Math blocks */
    .math-block {
      background: rgba(0,0,0,0.4);
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 16px;
      margin: 12px 0;
      font-family: ui-monospace, monospace;
      font-size: 14px;
      text-align: center;
    }
    .math-block.l2 { border-color: var(--l2); }
    .math-block.l1 { border-color: var(--l1); }
    
    /* Insight boxes */
    .insight {
      background: linear-gradient(135deg, rgba(100,255,218,0.08), rgba(167,139,250,0.08));
      border: 1px solid rgba(100,255,218,0.2);
      border-radius: 10px;
      padding: 12px 16px;
      margin-top: 12px;
    }
    .insight-title { font-weight: 600; color: var(--accent); margin-bottom: 6px; font-size: 13px; }
    .insight p { font-size: 13px; color: var(--muted); }
    
    /* Matrix display */
    .matrix-wrap {
      display: inline-block;
      padding: 8px 12px;
      border-left: 2px solid var(--muted);
      border-right: 2px solid var(--muted);
      margin: 8px 4px;
      background: rgba(0,0,0,0.2);
      border-radius: 4px;
    }
    .matrix-wrap table { border: none; }
    .matrix-wrap td { border: none; padding: 4px 8px; text-align: center; }
    
    /* Flow diagram */
    .flow { display: flex; align-items: center; justify-content: center; gap: 0; flex-wrap: wrap; padding: 16px; }
    .flow-step {
      background: rgba(0,0,0,0.4);
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 12px 16px;
      text-align: center;
      min-width: 100px;
    }
    .flow-step.active { border-color: var(--accent); }
    .flow-step .num { font-size: 11px; color: var(--accent); margin-bottom: 2px; }
    .flow-step .title { font-weight: 600; font-size: 12px; }
    .flow-arrow { font-size: 20px; color: var(--muted); padding: 0 6px; }
    
    /* Scrollable log */
    .log-wrap {
      max-height: 220px;
      overflow-y: auto;
      border: 1px solid var(--line);
      border-radius: 8px;
      margin-top: 10px;
    }
    .log-wrap table { font-size: 11px; }
    .log-wrap th, .log-wrap td { padding: 6px 8px; }
    
    /* KPI cards */
    .kpi { background: rgba(0,0,0,0.3); border: 1px solid var(--line); border-radius: 8px; padding: 10px; }
    .kpi-label { font-size: 10px; color: var(--muted); text-transform: uppercase; margin-bottom: 2px; }
    .kpi-value { font-family: monospace; font-size: 13px; color: var(--accent); }
    
    /* Color highlights */
    .hl-l2 { color: var(--l2); }
    .hl-l1 { color: var(--l1); }
    .hl-loss { color: var(--loss); }
    .hl-accent { color: var(--accent); }
    .hl-red { color: var(--red); }
    .hl-green { color: var(--green); }
    
    /* Small text */
    .small { font-size: 12px; color: var(--muted); }
    .tiny { font-size: 11px; color: var(--muted); }
    
    /* Pre */
    pre {
      background: #0a0b0f;
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 12px;
      font-family: ui-monospace, monospace;
      font-size: 12px;
      white-space: pre-wrap;
      word-break: break-word;
      margin: 10px 0;
      max-height: 300px;
      overflow-y: auto;
    }
    
    /* Footer */
    footer {
      text-align: center;
      padding: 30px 20px;
      color: var(--muted);
      font-size: 12px;
      border-top: 1px solid var(--line);
    }
    
    /* Dots */
    .dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
    .dot.l2 { background: var(--l2); }
    .dot.l1 { background: var(--l1); }
    .dot.loss { background: var(--loss); }
    .dot.ols { background: var(--green); }
  </style>
</head>
<body>
  <nav>
    <a href="#step1" class="step">Step 1: Data</a>
    <a href="#step2" class="step">Step 2: Design Matrix</a>
    <a href="#step3" class="step">Step 3: Hessian & Eigen</a>
    <a href="#step4" class="step">Step 4: OLS Solution</a>
    <a href="#step5" class="step">Step 5: L2 Ridge</a>
    <a href="#step6" class="step">Step 6: L1 Lasso</a>
    <a href="#playground">üéÆ Playground</a>
  </nav>

  <header>
    <h1>L1 vs L2 Regularization</h1>
    <p class="subtitle">From Raw Data to Geometry ‚Äî A Step-by-Step Journey</p>
  </header>

  <!-- STEP 1: Raw Data -->
  <section id="step1">
    <div class="section-header">
      <span class="step-badge">Step 1</span>
      <h2>Raw Data ‚Äî The Starting Point</h2>
    </div>
    
    <div class="grid-2">
      <div class="card">
        <div class="card-header">üìä Our Dataset (n=20 points)</div>
        <div class="card-body">
          <p class="small" style="margin-bottom: 10px;">
            We have 20 (x, y) pairs. Our goal: fit a <strong>quadratic curve</strong> to this data.
          </p>
          <div style="max-height: 280px; overflow-y: auto;">
            <table id="dataTable">
              <thead>
                <tr><th>i</th><th>x·µ¢</th><th>y·µ¢</th></tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>
      
      <div class="card">
        <div class="card-header">üìà Scatter Plot</div>
        <div class="card-body">
          <div class="canvas-wrap">
            <canvas id="cvStep1" width="600" height="400"></canvas>
          </div>
          <div class="insight">
            <div class="insight-title">üéØ The Goal</div>
            <p>Find the best quadratic curve <strong>≈∑ = ax¬≤ + bx + c</strong> that fits this data.</p>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- STEP 2: Design Matrix -->
  <section id="step2">
    <div class="section-header">
      <span class="step-badge">Step 2</span>
      <h2>Build the Design Matrix X</h2>
    </div>
    
    <div class="card">
      <div class="card-header">üîß From Data to Matrix Form</div>
      <div class="card-body">
        <p class="small" style="margin-bottom: 12px;">
          To use linear algebra, we rewrite the quadratic model in matrix form:
        </p>
        
        <div class="math-block">
          <strong>Model:</strong> ≈∑·µ¢ = a¬∑x·µ¢¬≤ + b¬∑x·µ¢ + c<br><br>
          <strong>Matrix form:</strong> ≈∑ = XŒ≤ &nbsp;&nbsp;where Œ≤ = [a, b, c]·µÄ
        </div>
        
        <div class="grid-2" style="margin-top: 16px;">
          <div>
            <h4 style="margin-bottom: 10px; font-size: 14px;">Design Matrix X (n√ó3)</h4>
            <p class="tiny" style="margin-bottom: 8px;">Each row: [x·µ¢¬≤, x·µ¢, 1]</p>
            <div style="max-height: 250px; overflow-y: auto;">
              <table id="designMatrix" class="mono">
                <thead>
                  <tr><th>i</th><th>x·µ¢¬≤</th><th>x·µ¢</th><th>1</th></tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
          
          <div>
            <h4 style="margin-bottom: 10px; font-size: 14px;">Target Vector y (n√ó1)</h4>
            <div style="max-height: 250px; overflow-y: auto;">
              <table id="yVector" class="mono">
                <thead>
                  <tr><th>i</th><th>y·µ¢</th></tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
        </div>
        
        <div class="insight">
          <div class="insight-title">üí° Why Matrix Form?</div>
          <p>Matrix form lets us use linear algebra to find the optimal Œ≤. The solution involves <strong>X·µÄX</strong> (the Hessian), which reveals the loss surface geometry.</p>
        </div>
      </div>
    </div>
  </section>

  <!-- STEP 3: Hessian & Eigendecomposition -->
  <section id="step3">
    <div class="section-header">
      <span class="step-badge">Step 3</span>
      <h2>Hessian Matrix & Eigendecomposition</h2>
    </div>
    
    <div class="grid-2">
      <div class="card">
        <div class="card-header">üßÆ Computing X·µÄX (Hessian)</div>
        <div class="card-body">
          <p class="small" style="margin-bottom: 12px;">
            The <strong>Hessian</strong> H = (2/n)X·µÄX determines the shape of the loss surface.
          </p>
          
          <div class="math-block">
            <strong>Loss Function:</strong><br>
            MSE = (1/n) ‚Äñy - XŒ≤‚Äñ¬≤<br><br>
            <strong>Hessian:</strong> H = (2/n) X·µÄX
          </div>
          
          <h4 style="margin: 16px 0 8px; font-size: 13px;">X·µÄX Matrix (3√ó3):</h4>
          <pre id="xtxMatrix" class="mono"></pre>
          
          <div class="tiny" style="margin-top: 8px;">
            This symmetric matrix encodes the curvature of the loss surface in each direction.
          </div>
        </div>
      </div>
      
      <div class="card">
        <div class="card-header">üî¨ Eigendecomposition</div>
        <div class="card-body">
          <p class="small" style="margin-bottom: 12px;">
            Decompose H = VŒõV·µÄ to understand the loss surface geometry.
          </p>
          
          <div class="math-block">
            H = V ¬∑ diag(Œª‚ÇÅ, Œª‚ÇÇ, Œª‚ÇÉ) ¬∑ V·µÄ
          </div>
          
          <h4 style="margin: 16px 0 8px; font-size: 13px;">Eigenvalues:</h4>
          <pre id="eigenvalues" class="mono"></pre>
          
          <h4 style="margin: 16px 0 8px; font-size: 13px;">Condition Number Œ∫:</h4>
          <pre id="conditionNum" class="mono"></pre>
          
          <div class="insight">
            <div class="insight-title">üéØ What Eigenvalues Tell Us</div>
            <p>
              <strong>Large eigenvalue</strong> = steep direction (well-determined)<br>
              <strong>Small eigenvalue</strong> = flat direction (poorly-determined)<br>
              <strong>High Œ∫</strong> = ill-conditioned problem = regularization helps!
            </p>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- STEP 4: OLS Solution -->
  <section id="step4">
    <div class="section-header">
      <span class="step-badge">Step 4</span>
      <h2>OLS Solution ‚Äî No Regularization</h2>
    </div>
    
    <div class="card">
      <div class="card-header"><span class="dot ols"></span> Ordinary Least Squares</div>
      <div class="card-body">
        <div class="grid-2">
          <div>
            <div class="math-block">
              <strong>OLS Objective:</strong><br>
              min<sub>Œ≤</sub> J(Œ≤) = (1/n) ‚Äñy - XŒ≤‚Äñ¬≤<br><br>
              <strong>Closed-form Solution:</strong><br>
              Œ≤* = (X·µÄX)‚Åª¬π X·µÄy
            </div>
            
            <h4 style="margin: 16px 0 8px; font-size: 13px;">OLS Solution Œ≤*:</h4>
            <pre id="olsSolution" class="mono"></pre>
            
            <h4 style="margin: 16px 0 8px; font-size: 13px;">Fitted Equation:</h4>
            <div id="olsEquation" class="math-block" style="text-align: left;"></div>
            
            <div class="grid-3" style="margin-top: 12px;">
              <div class="kpi">
                <div class="kpi-label">MSE</div>
                <div class="kpi-value" id="olsMSE">-</div>
              </div>
              <div class="kpi">
                <div class="kpi-label">a (x¬≤ coef)</div>
                <div class="kpi-value" id="olsA">-</div>
              </div>
              <div class="kpi">
                <div class="kpi-label">b (x coef)</div>
                <div class="kpi-value" id="olsB">-</div>
              </div>
            </div>
          </div>
          
          <div>
            <div class="canvas-wrap">
              <canvas id="cvStep4" width="600" height="400"></canvas>
            </div>
            <div class="tiny" style="margin-top: 8px;">
              OLS finds the Œ≤ that minimizes squared error. But coefficients can be large if data is noisy or ill-conditioned.
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- STEP 5: L2 Ridge -->
  <section id="step5">
    <div class="section-header">
      <span class="step-badge">Step 5</span>
      <h2>L2 Ridge Regularization</h2>
    </div>
    
    <div class="card">
      <div class="card-header"><span class="dot l2"></span> Ridge adds a circular penalty</div>
      <div class="card-body">
        <div class="math-block l2">
          <strong>Ridge Objective:</strong><br>
          J(Œ≤) = <span class="hl-loss">(1/n)‚Äñy - XŒ≤‚Äñ¬≤</span> + <span class="hl-l2">Œª‚Äñw‚Äñ‚ÇÇ¬≤</span><br><br>
          where w = [a, b] (often exclude intercept c from penalty)
        </div>
        
        <div class="grid-2" style="margin-top: 16px;">
          <div>
            <div class="math-block">
              <strong>Closed-form Solution:</strong><br>
              Œ≤ÃÇ = (X·µÄX + nŒªP)‚Åª¬π X·µÄy<br><br>
              <span class="tiny">P = diag(1,1,0) if not penalizing intercept</span>
            </div>
            
            <div class="controls">
              <div class="control-group">
                <label>Ridge Œª (manual)</label>
                <input type="range" id="ridgeLambda" min="0" max="3" step="0.01" value="0.5">
                <div class="control-value" id="ridgeLambdaVal">0.50</div>
              </div>
            </div>
            
            <h4 style="margin: 12px 0 8px; font-size: 13px;">Ridge Solution:</h4>
            <pre id="ridgeSolution" class="mono"></pre>
            
            <div class="grid-3" style="margin-top: 12px;">
              <div class="kpi">
                <div class="kpi-label">MSE (Train)</div>
                <div class="kpi-value" id="ridgeMSE">-</div>
              </div>
              <div class="kpi">
                <div class="kpi-label">L2 Penalty</div>
                <div class="kpi-value" id="ridgePen">-</div>
              </div>
              <div class="kpi">
                <div class="kpi-label">Total J</div>
                <div class="kpi-value" id="ridgeJ">-</div>
              </div>
            </div>
            
            <div class="insight">
              <div class="insight-title">üéØ Ridge Shrinkage Formula</div>
              <p>
                In eigen-coordinates: <strong class="hl-l2">·∫ë·µ¢ = (‚Ñì·µ¢ / (‚Ñì·µ¢ + Œª)) ¬∑ z·µ¢*</strong><br>
                Small eigenvalue directions shrink more!
              </p>
            </div>
          </div>
          
          <div>
            <div class="canvas-wrap">
              <canvas id="cvStep5" width="600" height="400"></canvas>
            </div>
            <div class="tiny" style="margin-top: 8px;">
              <span class="hl-l2">‚óè</span> L2 constraint is a <strong>circle</strong>. Solution lies where loss contours touch the circle.
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- NEW: Lambda Selection Section -->
    <div class="card" style="margin-top: 20px;">
      <div class="card-header"><span class="dot l2"></span> How to Select Œª? ‚Äî Cross-Validation</div>
      <div class="card-body">
        <p class="small" style="margin-bottom: 12px;">
          <strong>Problem:</strong> How do we choose the best Œª? Too small ‚Üí overfitting, too large ‚Üí underfitting.
        </p>
        
        <div class="math-block">
          <strong>Leave-One-Out Cross-Validation (LOOCV):</strong><br><br>
          CV(Œª) = (1/n) Œ£·µ¢ (y·µ¢ ‚àí ≈∑‚Çç‚Çã·µ¢‚Çé)¬≤ <br><br>
          <span class="tiny">where ≈∑‚Çç‚Çã·µ¢‚Çé is prediction for point i using model trained WITHOUT point i</span>
        </div>
        
        <div class="grid-2" style="margin-top: 16px;">
          <div>
            <h4 style="margin-bottom: 10px; font-size: 14px;">Œª Selection Methods:</h4>
            
            <div style="background: rgba(0,0,0,0.3); border: 1px solid var(--line); border-radius: 8px; padding: 12px; margin-bottom: 12px;">
              <div style="font-weight: 600; margin-bottom: 8px; font-size: 13px;">1Ô∏è‚É£ Cross-Validation (Most Common)</div>
              <p class="tiny">
                ‚Ä¢ Split data into K folds (or use LOOCV)<br>
                ‚Ä¢ For each Œª: train on K-1 folds, test on held-out fold<br>
                ‚Ä¢ Choose Œª that minimizes CV error<br>
                ‚Ä¢ <strong>Criterion: min CV(Œª)</strong>
              </p>
            </div>
            
            <div style="background: rgba(0,0,0,0.3); border: 1px solid var(--line); border-radius: 8px; padding: 12px; margin-bottom: 12px;">
              <div style="font-weight: 600; margin-bottom: 8px; font-size: 13px;">2Ô∏è‚É£ Generalized CV (GCV)</div>
              <p class="tiny">
                GCV(Œª) = (1/n) ¬∑ RSS(Œª) / [1 - tr(H)/n]¬≤<br>
                ‚Ä¢ H = X(X·µÄX + nŒªP)‚Åª¬πX·µÄ is the "hat matrix"<br>
                ‚Ä¢ Efficient approximation to LOOCV
              </p>
            </div>
            
            <div style="background: rgba(0,0,0,0.3); border: 1px solid var(--line); border-radius: 8px; padding: 12px;">
              <div style="font-weight: 600; margin-bottom: 8px; font-size: 13px;">3Ô∏è‚É£ Information Criteria</div>
              <p class="tiny">
                ‚Ä¢ AIC = n¬∑log(RSS/n) + 2¬∑df(Œª)<br>
                ‚Ä¢ BIC = n¬∑log(RSS/n) + log(n)¬∑df(Œª)<br>
                ‚Ä¢ df(Œª) = tr(H) = effective degrees of freedom
              </p>
            </div>
            
            <div class="btn-group" style="margin-top: 12px;">
              <button id="ridgeFindOptimal" class="l2" style="background: rgba(167,139,250,0.2);">‚ñ∂ Find Optimal Œª (LOOCV)</button>
              <button id="ridgeApplyOptimal" class="l2">Apply Optimal Œª</button>
            </div>
            
            <div id="ridgeOptimalResult" style="margin-top: 12px; padding: 10px; background: rgba(167,139,250,0.1); border: 1px solid var(--l2); border-radius: 8px; display: none;">
              <div class="mono" id="ridgeOptimalText"></div>
            </div>
          </div>
          
          <div>
            <h4 style="margin-bottom: 10px; font-size: 14px;">CV Error vs Œª (Bias-Variance Tradeoff)</h4>
            <div class="canvas-wrap">
              <canvas id="cvRidgeCV" width="600" height="350"></canvas>
            </div>
            <div class="tiny" style="margin-top: 8px;">
              <span class="hl-loss">‚Äî</span> Training MSE (always decreases with smaller Œª)<br>
              <span class="hl-l2">‚Äî</span> CV Error (U-shaped: finds optimal Œª)<br>
              <span class="hl-green">|</span> Optimal Œª (minimum CV error)
            </div>
          </div>
        </div>
        
        <div class="insight" style="margin-top: 16px;">
          <div class="insight-title">üìä Bias-Variance Tradeoff</div>
          <p>
            <strong>Œª too small (‚Üí 0):</strong> Low bias, high variance ‚Üí overfitting (fits training data well, but poor generalization)<br>
            <strong>Œª too large (‚Üí ‚àû):</strong> High bias, low variance ‚Üí underfitting (too simple, misses patterns)<br>
            <strong>Optimal Œª:</strong> Balances bias and variance ‚Üí best generalization (minimum CV error)
          </p>
        </div>
        
        <!-- Detailed CV Results Table -->
        <h4 style="margin: 20px 0 10px; font-size: 14px;">LOOCV Results for Different Œª Values:</h4>
        <div style="max-height: 200px; overflow-y: auto; border: 1px solid var(--line); border-radius: 8px;">
          <table id="ridgeCVTable">
            <thead>
              <tr>
                <th>Œª</th>
                <th>Train MSE</th>
                <th>CV Error</th>
                <th>L2 Penalty</th>
                <th>df(Œª)</th>
                <th>Status</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        
        <!-- Coefficient Path Plot -->
        <h4 style="margin: 20px 0 10px; font-size: 14px;">Ridge Coefficient Path (how Œ≤ changes with Œª):</h4>
        <div class="canvas-wrap">
          <canvas id="cvRidgePath" width="800" height="250"></canvas>
        </div>
        <div class="tiny" style="margin-top: 8px;">
          <span class="hl-red">‚Äî</span> a (x¬≤ coefficient) &nbsp;
          <span class="hl-green">‚Äî</span> b (x coefficient) &nbsp;
          <span class="hl-l2">‚Äî</span> c (intercept) &nbsp;
          <span style="color: var(--muted);">|</span> Current Œª &nbsp;
          <span class="hl-accent">|</span> Optimal Œª
        </div>
      </div>
    </div>
  </section>

  <!-- STEP 6: L1 Lasso -->
  <section id="step6">
    <div class="section-header">
      <span class="step-badge">Step 6</span>
      <h2>L1 Lasso Regularization</h2>
    </div>
    
    <div class="card">
      <div class="card-header"><span class="dot l1"></span> Lasso adds a diamond penalty</div>
      <div class="card-body">
        <div class="math-block l1">
          <strong>Lasso Objective:</strong><br>
          J(Œ≤) = <span class="hl-loss">(1/n)‚Äñy - XŒ≤‚Äñ¬≤</span> + <span class="hl-l1">Œª‚Äñw‚Äñ‚ÇÅ</span><br><br>
          where ‚Äñw‚Äñ‚ÇÅ = |a| + |b| (L1 norm)
        </div>
        
        <div class="grid-2" style="margin-top: 16px;">
          <div>
            <div class="math-block">
              <strong>No closed-form!</strong> Use Coordinate Descent:<br><br>
              For each j: Œ≤ÃÇ‚±º = soft(œÅ‚±º, Œª) / H‚±º‚±º<br>
              soft(x, Œª) = sign(x) ¬∑ max(|x| - Œª, 0)
            </div>
            
            <div class="controls">
              <div class="control-group">
                <label>Lasso Œª</label>
                <input type="range" id="lassoLambda" min="0" max="3" step="0.01" value="0.5">
                <div class="control-value" id="lassoLambdaVal">0.50</div>
              </div>
            </div>
            
            <div class="btn-group" style="margin: 10px 0;">
              <button id="lassoStep" class="l1">1 Coordinate Update</button>
              <button id="lassoSweep" class="l1">1 Full Sweep (a‚Üíb‚Üíc)</button>
              <button id="lassoFull" class="l1">Run 30 Sweeps</button>
              <button id="lassoConverge" class="l1" style="background: rgba(252,211,77,0.2);">‚ñ∂ Run Until Converged</button>
              <button id="lassoReset">Reset</button>
            </div>
            
            <h4 style="margin: 12px 0 8px; font-size: 13px;">Lasso Solution:</h4>
            <pre id="lassoSolution" class="mono"></pre>
            
            <div class="grid-3" style="margin-top: 12px;">
              <div class="kpi">
                <div class="kpi-label">MSE</div>
                <div class="kpi-value" id="lassoMSE">-</div>
              </div>
              <div class="kpi">
                <div class="kpi-label">L1 Penalty</div>
                <div class="kpi-value" id="lassoPen">-</div>
              </div>
              <div class="kpi">
                <div class="kpi-label">Zeros?</div>
                <div class="kpi-value" id="lassoZeros">-</div>
              </div>
            </div>
          </div>
          
          <div>
            <div class="canvas-wrap">
              <canvas id="cvStep6" width="600" height="400"></canvas>
            </div>
            <div class="tiny" style="margin-top: 8px;">
              <span class="hl-l1">‚óè</span> L1 constraint is a <strong>diamond</strong>. Corners ‚Üí exact zeros (sparsity)!
            </div>
            
            <h4 style="margin: 16px 0 8px; font-size: 13px;">Coordinate Descent Log:</h4>
            <div id="convergenceStatus" style="padding: 8px 12px; border-radius: 8px; margin-bottom: 8px; font-size: 12px; background: rgba(255,255,255,0.05); border: 1px solid var(--line);">
              <span id="convergenceText">Not started</span>
            </div>
            <div class="log-wrap">
              <table id="lassoLog">
                <thead>
                  <tr><th>Step</th><th>Param</th><th>œÅ</th><th>New Œ≤</th><th>J(Œ≤)</th><th>ŒîJ</th><th>Status</th></tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
            <div class="insight" style="margin-top: 12px;">
              <div class="insight-title">üõë When to Stop?</div>
              <p>
                <strong>Convergence criterion:</strong> Stop when |ŒîJ| < Œµ (e.g., Œµ = 10‚Åª‚Å∂)<br>
                This means the objective function is no longer improving significantly.
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- NEW: Lambda Selection for Lasso -->
    <div class="card" style="margin-top: 20px;">
      <div class="card-header"><span class="dot l1"></span> How to Select Œª for Lasso? ‚Äî Cross-Validation</div>
      <div class="card-body">
        <p class="small" style="margin-bottom: 12px;">
          Same principle as Ridge: use <strong>Cross-Validation</strong> to find Œª that minimizes prediction error.
        </p>
        
        <div class="grid-2">
          <div>
            <div class="math-block">
              <strong>K-Fold Cross-Validation:</strong><br><br>
              CV(Œª) = (1/K) Œ£‚Çñ MSE_k(Œª)<br><br>
              <span class="tiny">MSE_k = error on fold k using model trained on other K-1 folds</span>
            </div>
            
            <div class="btn-group" style="margin: 12px 0;">
              <button id="lassoFindOptimal" class="l1" style="background: rgba(252,211,77,0.2);">‚ñ∂ Find Optimal Œª (5-Fold CV)</button>
              <button id="lassoApplyOptimal" class="l1">Apply Optimal Œª</button>
            </div>
            
            <div id="lassoOptimalResult" style="margin-top: 12px; padding: 10px; background: rgba(252,211,77,0.1); border: 1px solid var(--l1); border-radius: 8px; display: none;">
              <div class="mono" id="lassoOptimalText"></div>
            </div>
            
            <div class="insight" style="margin-top: 16px;">
              <div class="insight-title">üéØ Lasso Path & Sparsity</div>
              <p>
                As Œª increases:<br>
                ‚Ä¢ More coefficients become <strong>exactly zero</strong><br>
                ‚Ä¢ Model becomes simpler (fewer features)<br>
                ‚Ä¢ "Lasso path" shows which features drop out first
              </p>
            </div>
          </div>
          
          <div>
            <h4 style="margin-bottom: 10px; font-size: 14px;">CV Error vs Œª + Coefficient Path</h4>
            <div class="canvas-wrap">
              <canvas id="cvLassoCV" width="600" height="350"></canvas>
            </div>
            <div class="tiny" style="margin-top: 8px;">
              <span class="hl-loss">‚Äî</span> Training MSE &nbsp;
              <span class="hl-l1">‚Äî</span> CV Error &nbsp;
              <span class="hl-green">|</span> Optimal Œª
            </div>
          </div>
        </div>
        
        <!-- Lasso Path Table -->
        <h4 style="margin: 20px 0 10px; font-size: 14px;">Lasso Path (Coefficients vs Œª):</h4>
        <div style="max-height: 200px; overflow-y: auto; border: 1px solid var(--line); border-radius: 8px;">
          <table id="lassoCVTable">
            <thead>
              <tr>
                <th>Œª</th>
                <th>a (x¬≤)</th>
                <th>b (x)</th>
                <th>c</th>
                <th>Zeros</th>
                <th>CV Error</th>
                <th>Status</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>
  </section>

  <!-- PLAYGROUND -->
  <section id="playground">
    <div class="section-header">
      <span class="step-badge">üéÆ</span>
      <h2>Interactive Playground</h2>
    </div>
    
    <div class="card">
      <div class="card-body">
        <p class="small" style="margin-bottom: 16px;">
          Compare OLS, Ridge, and Lasso side-by-side. Adjust Œª and see how solutions change!
        </p>
        
        <div class="controls">
          <div class="control-group">
            <label>Regularization Œª</label>
            <input type="range" id="playLambda" min="0" max="5" step="0.01" value="0.5">
            <div class="control-value" id="playLambdaVal">0.50</div>
          </div>
          <div class="control-group">
            <label>Penalize Intercept c?</label>
            <select id="playPenInt">
              <option value="no" selected>No (common practice)</option>
              <option value="yes">Yes</option>
            </select>
          </div>
        </div>
        
        <div class="grid-2" style="margin-top: 16px;">
          <div>
            <h4 style="margin-bottom: 10px; font-size: 14px;">Data + Fitted Curves</h4>
            <div class="canvas-wrap">
              <canvas id="cvPlayData" width="600" height="400"></canvas>
            </div>
            <div class="tiny" style="margin-top: 8px;">
              <span class="hl-green">‚óè</span> OLS &nbsp;
              <span class="hl-l2">‚óè</span> Ridge &nbsp;
              <span class="hl-l1">‚óè</span> Lasso
            </div>
          </div>
          
          <div>
            <h4 style="margin-bottom: 10px; font-size: 14px;">Geometry: (a, b) plane with c fixed</h4>
            <div class="canvas-wrap">
              <canvas id="cvPlayGeom" width="600" height="400"></canvas>
            </div>
            <div class="tiny" style="margin-top: 8px;">
              Loss contours (heatmap) + <span class="hl-l2">L2 circle</span> + <span class="hl-l1">L1 diamond</span>
            </div>
          </div>
        </div>
        
        <div class="grid-3" style="margin-top: 16px;">
          <div class="card" style="border-color: var(--green);">
            <div class="card-header"><span class="dot ols"></span> OLS (No Reg)</div>
            <div class="card-body">
              <div class="mono" id="playOLS"></div>
            </div>
          </div>
          <div class="card" style="border-color: var(--l2);">
            <div class="card-header"><span class="dot l2"></span> L2 Ridge</div>
            <div class="card-body">
              <div class="mono" id="playRidge"></div>
            </div>
          </div>
          <div class="card" style="border-color: var(--l1);">
            <div class="card-header"><span class="dot l1"></span> L1 Lasso</div>
            <div class="card-body">
              <div class="mono" id="playLasso"></div>
            </div>
          </div>
        </div>
        
        <!-- Comparison Table -->
        <h4 style="margin: 24px 0 12px; font-size: 14px;">Summary Comparison</h4>
        <table>
          <thead>
            <tr>
              <th style="text-align: left;">Property</th>
              <th>OLS</th>
              <th class="hl-l2">L2 Ridge</th>
              <th class="hl-l1">L1 Lasso</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Penalty</td>
              <td>None</td>
              <td class="hl-l2">Œª‚Äñw‚Äñ‚ÇÇ¬≤</td>
              <td class="hl-l1">Œª‚Äñw‚Äñ‚ÇÅ</td>
            </tr>
            <tr>
              <td>Constraint Shape</td>
              <td>‚Äî</td>
              <td class="hl-l2">Circle</td>
              <td class="hl-l1">Diamond</td>
            </tr>
            <tr>
              <td>Closed-form?</td>
              <td>Yes</td>
              <td class="hl-l2">Yes</td>
              <td class="hl-l1">No</td>
            </tr>
            <tr>
              <td>Sparsity?</td>
              <td>No</td>
              <td class="hl-l2">No</td>
              <td class="hl-l1">Yes!</td>
            </tr>
            <tr>
              <td>Best for</td>
              <td>Baseline</td>
              <td class="hl-l2">Multicollinearity</td>
              <td class="hl-l1">Feature selection</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>

  <footer>
    <p>Interactive L1/L2 Regularization Tutorial ‚Äî From Raw Data to Geometry</p>
  </footer>

  <script>
    // ==================== DATA ====================
    const data = [
      [2.88, 8.25], [-0.09, 3.18], [0.06, 1.45], [-2.56, 3.78], [2.98, 10.72],
      [-0.24, 3.57], [2.34, 8.97], [0.77, 2.05], [-0.16, 1.07], [1.63, 6.43],
      [0.88, 4.39], [1.72, 5.82], [-0.28, 0.05], [-1.04, 0.32], [1.51, 3.06],
      [-1.32, -0.19], [0.78, 4.78], [-0.91, 0.35], [-2.99, 4.20], [1.86, 3.77],
    ];
    const n = data.length;
    
    // Build design matrix
    const X = data.map(d => [d[0]*d[0], d[0], 1]);
    const y = data.map(d => d[1]);
    
    // ==================== LINEAR ALGEBRA ====================
    function dot(a, b) { return a.reduce((s, v, i) => s + v * b[i], 0); }
    
    function matMul(A, B) {
      const m = A.length, n = B[0].length, k = B.length;
      const C = Array(m).fill(0).map(() => Array(n).fill(0));
      for (let i = 0; i < m; i++)
        for (let j = 0; j < n; j++)
          for (let l = 0; l < k; l++)
            C[i][j] += A[i][l] * B[l][j];
      return C;
    }
    
    function matT(A) {
      const m = A.length, n = A[0].length;
      const T = Array(n).fill(0).map(() => Array(m).fill(0));
      for (let i = 0; i < m; i++)
        for (let j = 0; j < n; j++)
          T[j][i] = A[i][j];
      return T;
    }
    
    function matVec(A, v) {
      return A.map(row => dot(row, v));
    }
    
    function vecMatVec(A, v) {
      return dot(v, matVec(A, v));
    }
    
    // X·µÄX
    function computeXtX(X) {
      const XT = matT(X);
      return matMul(XT, X);
    }
    
    // X·µÄy
    function computeXty(X, y) {
      const XT = matT(X);
      return matVec(XT, y);
    }
    
    // 3x3 matrix inverse
    function inv3x3(M) {
      const [[a,b,c],[d,e,f],[g,h,i]] = M;
      const det = a*(e*i-f*h) - b*(d*i-f*g) + c*(d*h-e*g);
      if (Math.abs(det) < 1e-12) return null;
      const invDet = 1/det;
      return [
        [(e*i-f*h)*invDet, (c*h-b*i)*invDet, (b*f-c*e)*invDet],
        [(f*g-d*i)*invDet, (a*i-c*g)*invDet, (c*d-a*f)*invDet],
        [(d*h-e*g)*invDet, (b*g-a*h)*invDet, (a*e-b*d)*invDet]
      ];
    }
    
    // Matrix add
    function matAdd(A, B) {
      return A.map((row, i) => row.map((v, j) => v + B[i][j]));
    }
    
    // ==================== SOLVERS ====================
    const XtX = computeXtX(X);
    const Xty = computeXty(X, y);
    
    // OLS: Œ≤ = (X·µÄX)‚Åª¬πX·µÄy
    function olsSolve() {
      const inv = inv3x3(XtX);
      return matVec(inv, Xty);
    }
    
    // Ridge: Œ≤ = (X·µÄX + nŒªP)‚Åª¬πX·µÄy
    function ridgeSolve(lambda, penInt = false) {
      const P = penInt ? [[1,0,0],[0,1,0],[0,0,1]] : [[1,0,0],[0,1,0],[0,0,0]];
      const penalty = P.map(row => row.map(v => v * n * lambda));
      const A = matAdd(XtX, penalty);
      const inv = inv3x3(A);
      return matVec(inv, Xty);
    }
    
    // Lasso state
    let lassoState = {
      beta: [0, 0, 0],
      step: 0,
      nextParam: 0,
      log: [],
      prevJ: null,
      converged: false,
      convergenceThreshold: 1e-6
    };
    
    function lassoInit() {
      lassoState.beta = olsSolve().slice();
      lassoState.step = 0;
      lassoState.nextParam = 0;
      lassoState.log = [];
      lassoState.prevJ = null;
      lassoState.converged = false;
    }
    
    // Soft thresholding
    function soft(x, lambda) {
      if (x > lambda) return x - lambda;
      if (x < -lambda) return x + lambda;
      return 0;
    }
    
    // Coordinate descent update
    function lassoCoordUpdate(j, lambda, penInt = false) {
      const beta = lassoState.beta;
      // residual without j-th term
      let rho = 0;
      for (let i = 0; i < n; i++) {
        let pred = 0;
        for (let k = 0; k < 3; k++) {
          if (k !== j) pred += X[i][k] * beta[k];
        }
        rho += X[i][j] * (y[i] - pred);
      }
      
      const Hjj = XtX[j][j];
      
      // Apply penalty only if not intercept (j=2) or penInt is true
      const applyPen = (j < 2) || penInt;
      const newBeta = applyPen ? soft(rho, n * lambda / 2) / Hjj : rho / Hjj;
      
      return { rho, Hjj, newBeta };
    }
    
    function lassoOneStep(lambda, penInt = false) {
      const j = lassoState.nextParam;
      const names = ['a', 'b', 'c'];
      const res = lassoCoordUpdate(j, lambda, penInt);
      lassoState.beta[j] = res.newBeta;
      
      const J = objective('lasso', lassoState.beta, lambda, penInt);
      
      // Compute ŒîJ
      let deltaJ = null;
      let status = 'iterating';
      if (lassoState.prevJ !== null) {
        deltaJ = J - lassoState.prevJ;
        if (Math.abs(deltaJ) < lassoState.convergenceThreshold) {
          status = 'converged';
          lassoState.converged = true;
        } else if (deltaJ > 0) {
          status = 'increased!';
        } else {
          status = 'decreasing';
        }
      }
      lassoState.prevJ = J;
      
      lassoState.step++;
      lassoState.log.push({
        step: lassoState.step,
        param: names[j],
        rho: res.rho,
        newBeta: res.newBeta,
        J: J,
        deltaJ: deltaJ,
        status: status
      });
      
      lassoState.nextParam = (lassoState.nextParam + 1) % 3;
    }
    
    function lassoSweep(lambda, penInt = false) {
      lassoOneStep(lambda, penInt);
      lassoOneStep(lambda, penInt);
      lassoOneStep(lambda, penInt);
    }
    
    function lassoFull(lambda, penInt = false) {
      for (let i = 0; i < 30; i++) {
        lassoSweep(lambda, penInt);
      }
    }
    
    // ==================== RIDGE CROSS-VALIDATION ====================
    
    // Compute hat matrix trace (effective degrees of freedom)
    function computeHatMatrixTrace(lambda, penInt = false) {
      const P = penInt ? [[1,0,0],[0,1,0],[0,0,1]] : [[1,0,0],[0,1,0],[0,0,0]];
      const penalty = P.map(row => row.map(v => v * n * lambda));
      const A = matAdd(XtX, penalty);
      const Ainv = inv3x3(A);
      if (!Ainv) return 3;
      
      // tr(H) = tr(X * Ainv * X^T) = tr(Ainv * X^T * X) = tr(Ainv * XtX)
      let trace = 0;
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          trace += Ainv[i][j] * XtX[j][i];
        }
      }
      return trace;
    }
    
    // Leave-One-Out Cross-Validation for Ridge (efficient formula)
    function ridgeLOOCV(lambda, penInt = false) {
      const beta = ridgeSolve(lambda, penInt);
      
      // Compute hat matrix H = X (X'X + nŒªP)^{-1} X'
      const P = penInt ? [[1,0,0],[0,1,0],[0,0,1]] : [[1,0,0],[0,1,0],[0,0,0]];
      const penalty = P.map(row => row.map(v => v * n * lambda));
      const A = matAdd(XtX, penalty);
      const Ainv = inv3x3(A);
      if (!Ainv) return Infinity;
      
      // Compute diagonal elements of H = X * Ainv * X'
      // h_ii = X[i] * Ainv * X[i]'
      const h = [];
      for (let i = 0; i < n; i++) {
        const xi = X[i];
        const AinvXi = matVec(Ainv, xi);
        h[i] = dot(xi, AinvXi);
      }
      
      // LOOCV formula: CV = (1/n) * Œ£ [(y_i - ≈∑_i) / (1 - h_ii)]^2
      let cv = 0;
      for (let i = 0; i < n; i++) {
        const pred = dot(X[i], beta);
        const residual = y[i] - pred;
        const loocvResid = residual / (1 - h[i]);
        cv += loocvResid * loocvResid;
      }
      return cv / n;
    }
    
    // Generalized Cross-Validation
    function ridgeGCV(lambda, penInt = false) {
      const beta = ridgeSolve(lambda, penInt);
      const rss = mse(beta) * n;
      const df = computeHatMatrixTrace(lambda, penInt);
      const denom = (1 - df / n);
      if (Math.abs(denom) < 1e-10) return Infinity;
      return (rss / n) / (denom * denom);
    }
    
    // Find optimal lambda using grid search
    function findOptimalRidgeLambda(penInt = false) {
      const lambdas = [];
      // Log-spaced grid from 0.001 to 10
      for (let i = -3; i <= 1; i += 0.1) {
        lambdas.push(Math.pow(10, i));
      }
      // Also include some small values
      lambdas.unshift(0.0001, 0.0005);
      lambdas.sort((a, b) => a - b);
      
      let bestLambda = 0.01;
      let bestCV = Infinity;
      const results = [];
      
      for (const lam of lambdas) {
        const cv = ridgeLOOCV(lam, penInt);
        const trainMSE = mse(ridgeSolve(lam, penInt));
        const df = computeHatMatrixTrace(lam, penInt);
        const pen = l2Penalty(ridgeSolve(lam, penInt), penInt);
        
        results.push({
          lambda: lam,
          cv: cv,
          trainMSE: trainMSE,
          df: df,
          penalty: pen,
          isBest: false
        });
        
        if (cv < bestCV) {
          bestCV = cv;
          bestLambda = lam;
        }
      }
      
      // Mark the best one
      for (const r of results) {
        if (r.lambda === bestLambda) {
          r.isBest = true;
        }
      }
      
      return { bestLambda, bestCV, results };
    }
    
    // Draw CV plot
    function drawRidgeCVPlot(results, currentLambda) {
      const canvas = document.getElementById('cvRidgeCV');
      const ctx = canvas.getContext('2d');
      const W = canvas.width, H = canvas.height;
      const pad = { left: 60, right: 20, top: 30, bottom: 40 };
      
      // Clear
      ctx.fillStyle = '#0a0b0f';
      ctx.fillRect(0, 0, W, H);
      
      // Get data ranges
      const lambdas = results.map(r => r.lambda);
      const cvs = results.map(r => r.cv).filter(v => isFinite(v));
      const mses = results.map(r => r.trainMSE).filter(v => isFinite(v));
      
      const xMin = Math.log10(Math.min(...lambdas));
      const xMax = Math.log10(Math.max(...lambdas));
      const yMin = Math.min(...cvs, ...mses) * 0.9;
      const yMax = Math.max(...cvs, ...mses) * 1.1;
      
      const toX = lam => pad.left + (Math.log10(lam) - xMin) / (xMax - xMin) * (W - pad.left - pad.right);
      const toY = val => H - pad.bottom - (val - yMin) / (yMax - yMin) * (H - pad.top - pad.bottom);
      
      // Grid
      ctx.strokeStyle = 'rgba(255,255,255,0.05)';
      ctx.lineWidth = 1;
      for (let i = Math.ceil(xMin); i <= xMax; i++) {
        const px = toX(Math.pow(10, i));
        ctx.beginPath();
        ctx.moveTo(px, pad.top);
        ctx.lineTo(px, H - pad.bottom);
        ctx.stroke();
      }
      
      // Axes
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx.beginPath();
      ctx.moveTo(pad.left, H - pad.bottom);
      ctx.lineTo(W - pad.right, H - pad.bottom);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(pad.left, pad.top);
      ctx.lineTo(pad.left, H - pad.bottom);
      ctx.stroke();
      
      // Draw training MSE line
      ctx.strokeStyle = '#60a5fa';
      ctx.lineWidth = 2;
      ctx.beginPath();
      let first = true;
      for (const r of results) {
        if (!isFinite(r.trainMSE)) continue;
        const px = toX(r.lambda);
        const py = toY(r.trainMSE);
        if (first) { ctx.moveTo(px, py); first = false; }
        else ctx.lineTo(px, py);
      }
      ctx.stroke();
      
      // Draw CV error line
      ctx.strokeStyle = '#a78bfa';
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      first = true;
      for (const r of results) {
        if (!isFinite(r.cv)) continue;
        const px = toX(r.lambda);
        const py = toY(r.cv);
        if (first) { ctx.moveTo(px, py); first = false; }
        else ctx.lineTo(px, py);
      }
      ctx.stroke();
      
      // Mark optimal lambda
      const best = results.find(r => r.isBest);
      if (best) {
        ctx.strokeStyle = '#4ade80';
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 4]);
        const px = toX(best.lambda);
        ctx.beginPath();
        ctx.moveTo(px, pad.top);
        ctx.lineTo(px, H - pad.bottom);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Mark point
        ctx.fillStyle = '#4ade80';
        ctx.beginPath();
        ctx.arc(px, toY(best.cv), 6, 0, Math.PI * 2);
        ctx.fill();
        
        // Label
        ctx.fillStyle = '#4ade80';
        ctx.font = '11px system-ui';
        ctx.fillText(`Œª* = ${best.lambda.toFixed(4)}`, px + 8, toY(best.cv) - 8);
      }
      
      // Mark current lambda
      if (currentLambda > 0) {
        ctx.strokeStyle = '#fcd34d';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([2, 2]);
        const px = toX(currentLambda);
        ctx.beginPath();
        ctx.moveTo(px, pad.top);
        ctx.lineTo(px, H - pad.bottom);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      
      // Axis labels
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.font = '11px system-ui';
      ctx.fillText('log‚ÇÅ‚ÇÄ(Œª)', W/2, H - 8);
      ctx.save();
      ctx.translate(14, H/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText('Error', 0, 0);
      ctx.restore();
      
      // Legend
      ctx.fillStyle = '#60a5fa';
      ctx.fillRect(W - 120, 10, 12, 3);
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.font = '10px system-ui';
      ctx.fillText('Train MSE', W - 105, 14);
      
      ctx.fillStyle = '#a78bfa';
      ctx.fillRect(W - 120, 22, 12, 3);
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.fillText('CV Error', W - 105, 26);
    }
    
    // Populate CV results table
    function populateRidgeCVTable(results) {
      const tbody = document.querySelector('#ridgeCVTable tbody');
      tbody.innerHTML = results.filter((r, i) => i % 3 === 0 || r.isBest).map(r => {
        const rowClass = r.isBest ? 'style="background: rgba(74,222,128,0.15);"' : '';
        const status = r.isBest ? '<span class="hl-green">‚òÖ OPTIMAL</span>' : '';
        return `<tr ${rowClass}>
          <td class="mono">${r.lambda.toFixed(4)}</td>
          <td class="mono">${r.trainMSE.toFixed(6)}</td>
          <td class="mono">${r.cv.toFixed(6)}</td>
          <td class="mono">${r.penalty.toFixed(6)}</td>
          <td class="mono">${r.df.toFixed(3)}</td>
          <td>${status}</td>
        </tr>`;
      }).join('');
    }
    
    // Draw Ridge Coefficient Path
    function drawRidgeCoefficientPath(results, currentLambda, optimalLambda) {
      const canvas = document.getElementById('cvRidgePath');
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      const W = canvas.width, H = canvas.height;
      const pad = { left: 60, right: 20, top: 20, bottom: 35 };
      
      // Clear
      ctx.fillStyle = '#0a0b0f';
      ctx.fillRect(0, 0, W, H);
      
      // Compute coefficient path
      const lambdas = [];
      const aVals = [], bVals = [], cVals = [];
      
      for (let i = -3; i <= 1; i += 0.1) {
        const lam = Math.pow(10, i);
        lambdas.push(lam);
        const beta = ridgeSolve(lam, false);
        aVals.push(beta[0]);
        bVals.push(beta[1]);
        cVals.push(beta[2]);
      }
      
      // Also add Œª=0 (OLS)
      lambdas.unshift(0.0001);
      const olsBeta = olsSolve();
      aVals.unshift(olsBeta[0]);
      bVals.unshift(olsBeta[1]);
      cVals.unshift(olsBeta[2]);
      
      // Ranges
      const xMin = Math.log10(0.0001), xMax = Math.log10(10);
      const allVals = [...aVals, ...bVals, ...cVals];
      const yMin = Math.min(...allVals) - 0.2;
      const yMax = Math.max(...allVals) + 0.2;
      
      const toX = lam => pad.left + (Math.log10(Math.max(lam, 0.0001)) - xMin) / (xMax - xMin) * (W - pad.left - pad.right);
      const toY = val => H - pad.bottom - (val - yMin) / (yMax - yMin) * (H - pad.top - pad.bottom);
      
      // Grid
      ctx.strokeStyle = 'rgba(255,255,255,0.05)';
      ctx.lineWidth = 1;
      for (let i = -3; i <= 1; i++) {
        const px = toX(Math.pow(10, i));
        ctx.beginPath();
        ctx.moveTo(px, pad.top);
        ctx.lineTo(px, H - pad.bottom);
        ctx.stroke();
      }
      
      // Zero line
      ctx.strokeStyle = 'rgba(255,255,255,0.2)';
      ctx.beginPath();
      ctx.moveTo(pad.left, toY(0));
      ctx.lineTo(W - pad.right, toY(0));
      ctx.stroke();
      
      // Draw coefficient lines
      function drawLine(vals, color) {
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < lambdas.length; i++) {
          const px = toX(lambdas[i]);
          const py = toY(vals[i]);
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.stroke();
      }
      
      drawLine(aVals, '#f87171'); // red for a
      drawLine(bVals, '#4ade80'); // green for b
      drawLine(cVals, '#a78bfa'); // purple for c
      
      // Current lambda line
      if (currentLambda > 0) {
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 4]);
        const px = toX(currentLambda);
        ctx.beginPath();
        ctx.moveTo(px, pad.top);
        ctx.lineTo(px, H - pad.bottom);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Label
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.font = '10px system-ui';
        ctx.fillText(`Œª=${currentLambda.toFixed(2)}`, px + 3, pad.top + 12);
      }
      
      // Optimal lambda line
      if (optimalLambda > 0) {
        ctx.strokeStyle = '#64ffda';
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 4]);
        const px = toX(optimalLambda);
        ctx.beginPath();
        ctx.moveTo(px, pad.top);
        ctx.lineTo(px, H - pad.bottom);
        ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.fillStyle = '#64ffda';
        ctx.font = '10px system-ui';
        ctx.fillText(`Œª*=${optimalLambda.toFixed(4)}`, px + 3, H - pad.bottom - 5);
      }
      
      // Axes
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(pad.left, H - pad.bottom);
      ctx.lineTo(W - pad.right, H - pad.bottom);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(pad.left, pad.top);
      ctx.lineTo(pad.left, H - pad.bottom);
      ctx.stroke();
      
      // Labels
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.font = '11px system-ui';
      ctx.fillText('log‚ÇÅ‚ÇÄ(Œª)', W/2, H - 5);
      ctx.save();
      ctx.translate(12, H/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText('Coefficient Value', 0, 0);
      ctx.restore();
      
      // X-axis labels
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.font = '9px monospace';
      for (let i = -3; i <= 1; i++) {
        const px = toX(Math.pow(10, i));
        ctx.fillText(`10^${i}`, px - 12, H - pad.bottom + 12);
      }
    }
    
    // Store optimal lambda result
    let ridgeOptimalResult = null;
    
    // ==================== LASSO CROSS-VALIDATION ====================
    
    // Solve Lasso for a given lambda (run coordinate descent to convergence)
    function lassoSolveForCV(lambda, penInt = false) {
      let beta = olsSolve().slice();
      const maxIter = 500;
      const tol = 1e-8;
      
      for (let iter = 0; iter < maxIter; iter++) {
        const oldBeta = beta.slice();
        
        // Coordinate descent sweep
        for (let j = 0; j < 3; j++) {
          let rho = 0;
          for (let i = 0; i < n; i++) {
            let pred = 0;
            for (let k = 0; k < 3; k++) {
              if (k !== j) pred += X[i][k] * beta[k];
            }
            rho += X[i][j] * (y[i] - pred);
          }
          
          const Hjj = XtX[j][j];
          const applyPen = (j < 2) || penInt;
          beta[j] = applyPen ? soft(rho, n * lambda / 2) / Hjj : rho / Hjj;
        }
        
        // Check convergence
        let maxDiff = 0;
        for (let j = 0; j < 3; j++) {
          maxDiff = Math.max(maxDiff, Math.abs(beta[j] - oldBeta[j]));
        }
        if (maxDiff < tol) break;
      }
      
      return beta;
    }
    
    // K-Fold CV for Lasso (simplified 5-fold)
    function lassoKFoldCV(lambda, penInt = false, K = 5) {
      const foldSize = Math.floor(n / K);
      let totalError = 0;
      
      for (let fold = 0; fold < K; fold++) {
        // Split data
        const testStart = fold * foldSize;
        const testEnd = (fold === K - 1) ? n : (fold + 1) * foldSize;
        
        const trainX = [];
        const trainY = [];
        const testX = [];
        const testY = [];
        
        for (let i = 0; i < n; i++) {
          if (i >= testStart && i < testEnd) {
            testX.push(X[i]);
            testY.push(y[i]);
          } else {
            trainX.push(X[i]);
            trainY.push(y[i]);
          }
        }
        
        // Train Lasso on training set
        const trainXtX = computeXtX(trainX);
        const trainXty = computeXty(trainX, trainY);
        const trainN = trainX.length;
        
        // Simplified: use global XtX approximation for speed
        // In practice, you'd recompute for each fold
        let beta = olsSolve().slice();
        const maxIter = 200;
        
        for (let iter = 0; iter < maxIter; iter++) {
          const oldBeta = beta.slice();
          for (let j = 0; j < 3; j++) {
            let rho = 0;
            for (let i = 0; i < trainX.length; i++) {
              let pred = 0;
              for (let k = 0; k < 3; k++) {
                if (k !== j) pred += trainX[i][k] * beta[k];
              }
              rho += trainX[i][j] * (trainY[i] - pred);
            }
            const Hjj = trainXtX[j][j];
            const applyPen = (j < 2) || penInt;
            beta[j] = applyPen ? soft(rho, trainN * lambda / 2) / Hjj : rho / Hjj;
          }
          
          let maxDiff = 0;
          for (let j = 0; j < 3; j++) {
            maxDiff = Math.max(maxDiff, Math.abs(beta[j] - oldBeta[j]));
          }
          if (maxDiff < 1e-6) break;
        }
        
        // Evaluate on test set
        let foldError = 0;
        for (let i = 0; i < testX.length; i++) {
          const pred = dot(testX[i], beta);
          foldError += (testY[i] - pred) ** 2;
        }
        totalError += foldError / testX.length;
      }
      
      return totalError / K;
    }
    
    // Find optimal lambda for Lasso
    function findOptimalLassoLambda(penInt = false) {
      const lambdas = [];
      for (let i = -3; i <= 0.5; i += 0.15) {
        lambdas.push(Math.pow(10, i));
      }
      lambdas.unshift(0.0001, 0.0005);
      lambdas.sort((a, b) => a - b);
      
      let bestLambda = 0.01;
      let bestCV = Infinity;
      const results = [];
      
      for (const lam of lambdas) {
        const beta = lassoSolveForCV(lam, penInt);
        const cv = lassoKFoldCV(lam, penInt, 5);
        const trainMSE = mse(beta);
        const zeros = (Math.abs(beta[0]) < 0.0001 ? 1 : 0) + (Math.abs(beta[1]) < 0.0001 ? 1 : 0);
        
        results.push({
          lambda: lam,
          beta: beta,
          cv: cv,
          trainMSE: trainMSE,
          zeros: zeros,
          isBest: false
        });
        
        if (cv < bestCV) {
          bestCV = cv;
          bestLambda = lam;
        }
      }
      
      for (const r of results) {
        if (r.lambda === bestLambda) {
          r.isBest = true;
        }
      }
      
      return { bestLambda, bestCV, results };
    }
    
    // Draw Lasso CV plot
    function drawLassoCVPlot(results, currentLambda) {
      const canvas = document.getElementById('cvLassoCV');
      const ctx = canvas.getContext('2d');
      const W = canvas.width, H = canvas.height;
      const pad = { left: 60, right: 20, top: 30, bottom: 40 };
      
      ctx.fillStyle = '#0a0b0f';
      ctx.fillRect(0, 0, W, H);
      
      const lambdas = results.map(r => r.lambda);
      const cvs = results.map(r => r.cv).filter(v => isFinite(v));
      const mses = results.map(r => r.trainMSE).filter(v => isFinite(v));
      
      const xMin = Math.log10(Math.min(...lambdas));
      const xMax = Math.log10(Math.max(...lambdas));
      const yMin = Math.min(...cvs, ...mses) * 0.9;
      const yMax = Math.max(...cvs, ...mses) * 1.1;
      
      const toX = lam => pad.left + (Math.log10(lam) - xMin) / (xMax - xMin) * (W - pad.left - pad.right);
      const toY = val => H - pad.bottom - (val - yMin) / (yMax - yMin) * (H - pad.top - pad.bottom);
      
      // Grid
      ctx.strokeStyle = 'rgba(255,255,255,0.05)';
      ctx.lineWidth = 1;
      for (let i = Math.ceil(xMin); i <= xMax; i++) {
        const px = toX(Math.pow(10, i));
        ctx.beginPath();
        ctx.moveTo(px, pad.top);
        ctx.lineTo(px, H - pad.bottom);
        ctx.stroke();
      }
      
      // Axes
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx.beginPath();
      ctx.moveTo(pad.left, H - pad.bottom);
      ctx.lineTo(W - pad.right, H - pad.bottom);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(pad.left, pad.top);
      ctx.lineTo(pad.left, H - pad.bottom);
      ctx.stroke();
      
      // Training MSE
      ctx.strokeStyle = '#60a5fa';
      ctx.lineWidth = 2;
      ctx.beginPath();
      let first = true;
      for (const r of results) {
        if (!isFinite(r.trainMSE)) continue;
        const px = toX(r.lambda);
        const py = toY(r.trainMSE);
        if (first) { ctx.moveTo(px, py); first = false; }
        else ctx.lineTo(px, py);
      }
      ctx.stroke();
      
      // CV error
      ctx.strokeStyle = '#fcd34d';
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      first = true;
      for (const r of results) {
        if (!isFinite(r.cv)) continue;
        const px = toX(r.lambda);
        const py = toY(r.cv);
        if (first) { ctx.moveTo(px, py); first = false; }
        else ctx.lineTo(px, py);
      }
      ctx.stroke();
      
      // Optimal
      const best = results.find(r => r.isBest);
      if (best) {
        ctx.strokeStyle = '#4ade80';
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 4]);
        const px = toX(best.lambda);
        ctx.beginPath();
        ctx.moveTo(px, pad.top);
        ctx.lineTo(px, H - pad.bottom);
        ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.fillStyle = '#4ade80';
        ctx.beginPath();
        ctx.arc(px, toY(best.cv), 6, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.font = '11px system-ui';
        ctx.fillText(`Œª* = ${best.lambda.toFixed(4)}`, px + 8, toY(best.cv) - 8);
      }
      
      // Labels
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.font = '11px system-ui';
      ctx.fillText('log‚ÇÅ‚ÇÄ(Œª)', W/2, H - 8);
      
      // Legend
      ctx.fillStyle = '#60a5fa';
      ctx.fillRect(W - 120, 10, 12, 3);
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.font = '10px system-ui';
      ctx.fillText('Train MSE', W - 105, 14);
      
      ctx.fillStyle = '#fcd34d';
      ctx.fillRect(W - 120, 22, 12, 3);
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.fillText('CV Error', W - 105, 26);
    }
    
    // Populate Lasso CV table
    function populateLassoCVTable(results) {
      const tbody = document.querySelector('#lassoCVTable tbody');
      tbody.innerHTML = results.filter((r, i) => i % 2 === 0 || r.isBest).map(r => {
        const rowClass = r.isBest ? 'style="background: rgba(74,222,128,0.15);"' : '';
        const status = r.isBest ? '<span class="hl-green">‚òÖ OPTIMAL</span>' : '';
        const aClass = Math.abs(r.beta[0]) < 0.0001 ? 'hl-l1' : '';
        const bClass = Math.abs(r.beta[1]) < 0.0001 ? 'hl-l1' : '';
        return `<tr ${rowClass}>
          <td class="mono">${r.lambda.toFixed(4)}</td>
          <td class="mono ${aClass}">${r.beta[0].toFixed(4)}</td>
          <td class="mono ${bClass}">${r.beta[1].toFixed(4)}</td>
          <td class="mono">${r.beta[2].toFixed(4)}</td>
          <td>${r.zeros}</td>
          <td class="mono">${r.cv.toFixed(6)}</td>
          <td>${status}</td>
        </tr>`;
      }).join('');
    }
    
    let lassoOptimalResult = null;

    // ==================== METRICS ====================
    function mse(beta) {
      let sum = 0;
      for (let i = 0; i < n; i++) {
        const pred = dot(X[i], beta);
        sum += (y[i] - pred) ** 2;
      }
      return sum / n;
    }
    
    function l2Penalty(beta, penInt = false) {
      const a = beta[0], b = beta[1], c = beta[2];
      return penInt ? a*a + b*b + c*c : a*a + b*b;
    }
    
    function l1Penalty(beta, penInt = false) {
      const a = beta[0], b = beta[1], c = beta[2];
      return penInt ? Math.abs(a) + Math.abs(b) + Math.abs(c) : Math.abs(a) + Math.abs(b);
    }
    
    function objective(type, beta, lambda, penInt = false) {
      const m = mse(beta);
      if (type === 'ols') return m;
      if (type === 'ridge') return m + lambda * l2Penalty(beta, penInt);
      if (type === 'lasso') return m + lambda * l1Penalty(beta, penInt);
      return m;
    }
    
    // ==================== EIGENVALUES (Power iteration approx) ====================
    function getEigenvaluesApprox() {
      // For 3x3, use characteristic polynomial or simple power iteration
      // Simple approach: return diagonal dominance approximation
      const H = XtX.map(row => row.map(v => 2 * v / n));
      
      // For demo, compute eigenvalues numerically (simplified)
      // Using Gershgorin bounds as approximation
      const eigs = [];
      for (let i = 0; i < 3; i++) {
        let radius = 0;
        for (let j = 0; j < 3; j++) {
          if (i !== j) radius += Math.abs(H[i][j]);
        }
        eigs.push({ center: H[i][i], radius });
      }
      return eigs;
    }
    
    // ==================== DRAWING ====================
    const fmt = (x, d=4) => x.toFixed(d);
    
    // Draw scatter plot with optional curve
    function drawScatter(canvasId, beta = null, options = {}) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext('2d');
      const W = canvas.width, H = canvas.height;
      const pad = 40;
      
      // Data bounds
      const xs = data.map(d => d[0]);
      const ys = data.map(d => d[1]);
      const xMin = Math.min(...xs) - 0.5, xMax = Math.max(...xs) + 0.5;
      const yMin = Math.min(...ys) - 1, yMax = Math.max(...ys) + 1;
      
      const toX = x => pad + (x - xMin) / (xMax - xMin) * (W - 2*pad);
      const toY = y => H - pad - (y - yMin) / (yMax - yMin) * (H - 2*pad);
      
      // Clear
      ctx.fillStyle = '#0a0b0f';
      ctx.fillRect(0, 0, W, H);
      
      // Grid
      ctx.strokeStyle = 'rgba(255,255,255,0.05)';
      ctx.lineWidth = 1;
      for (let x = Math.ceil(xMin); x <= xMax; x++) {
        ctx.beginPath();
        ctx.moveTo(toX(x), pad);
        ctx.lineTo(toX(x), H - pad);
        ctx.stroke();
      }
      for (let y = Math.ceil(yMin); y <= yMax; y += 2) {
        ctx.beginPath();
        ctx.moveTo(pad, toY(y));
        ctx.lineTo(W - pad, toY(y));
        ctx.stroke();
      }
      
      // Axes
      ctx.strokeStyle = 'rgba(255,255,255,0.2)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(toX(0), pad);
      ctx.lineTo(toX(0), H - pad);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(pad, toY(0));
      ctx.lineTo(W - pad, toY(0));
      ctx.stroke();
      
      // Draw curves if provided
      if (options.curves) {
        for (const curve of options.curves) {
          ctx.strokeStyle = curve.color;
          ctx.lineWidth = 2;
          ctx.beginPath();
          for (let px = pad; px <= W - pad; px++) {
            const x = xMin + (px - pad) / (W - 2*pad) * (xMax - xMin);
            const yVal = curve.beta[0]*x*x + curve.beta[1]*x + curve.beta[2];
            const py = toY(yVal);
            if (px === pad) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          ctx.stroke();
        }
      } else if (beta) {
        ctx.strokeStyle = options.color || '#4ade80';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let px = pad; px <= W - pad; px++) {
          const x = xMin + (px - pad) / (W - 2*pad) * (xMax - xMin);
          const yVal = beta[0]*x*x + beta[1]*x + beta[2];
          const py = toY(yVal);
          if (px === pad) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.stroke();
      }
      
      // Data points
      ctx.fillStyle = '#60a5fa';
      for (const d of data) {
        ctx.beginPath();
        ctx.arc(toX(d[0]), toY(d[1]), 5, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Labels
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.font = '11px system-ui';
      ctx.fillText('x', W - pad + 5, H - pad + 4);
      ctx.fillText('y', pad - 5, pad - 5);
    }
    
    // Draw geometry plot (a,b plane)
    function drawGeometry(canvasId, betaOLS, betaRidge, betaLasso, lambda, penInt) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext('2d');
      const W = canvas.width, H = canvas.height;
      const pad = 50;
      
      // Fixed c value (from OLS)
      const cFix = betaOLS[2];
      
      // View range
      const aOLS = betaOLS[0], bOLS = betaOLS[1];
      const range = Math.max(Math.abs(aOLS), Math.abs(bOLS)) * 1.8 + 0.5;
      const aMin = -range, aMax = range;
      const bMin = -range, bMax = range;
      
      const toX = a => pad + (a - aMin) / (aMax - aMin) * (W - 2*pad);
      const toY = b => H - pad - (b - bMin) / (bMax - bMin) * (H - 2*pad);
      
      // Clear
      ctx.fillStyle = '#0a0b0f';
      ctx.fillRect(0, 0, W, H);
      
      // Heatmap of MSE
      const resolution = 80;
      for (let i = 0; i < resolution; i++) {
        for (let j = 0; j < resolution; j++) {
          const a = aMin + (i + 0.5) / resolution * (aMax - aMin);
          const b = bMin + (j + 0.5) / resolution * (bMax - bMin);
          const beta = [a, b, cFix];
          const m = mse(beta);
          const intensity = Math.exp(-m / 5);
          const r = Math.floor(30 + intensity * 60);
          const g = Math.floor(30 + intensity * 100);
          const bVal = Math.floor(50 + intensity * 150);
          ctx.fillStyle = `rgb(${r},${g},${bVal})`;
          const px = pad + i / resolution * (W - 2*pad);
          const py = H - pad - (j + 1) / resolution * (H - 2*pad);
          const pw = (W - 2*pad) / resolution;
          const ph = (H - 2*pad) / resolution;
          ctx.fillRect(px, py, pw + 1, ph + 1);
        }
      }
      
      // Contour lines
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = 1;
      const levels = [0.5, 1, 2, 4, 8];
      for (const level of levels) {
        // Draw contour at MSE = level (approximate with ellipse)
        const pts = [];
        for (let t = 0; t <= 100; t++) {
          const angle = t / 100 * Math.PI * 2;
          const r = Math.sqrt(level) * 1.5;
          const a = aOLS + r * Math.cos(angle) * 0.8;
          const b = bOLS + r * Math.sin(angle) * 1.2;
          pts.push([a, b]);
        }
        ctx.beginPath();
        for (let k = 0; k < pts.length; k++) {
          const px = toX(pts[k][0]), py = toY(pts[k][1]);
          if (k === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.stroke();
      }
      
      // Axes
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(toX(0), pad);
      ctx.lineTo(toX(0), H - pad);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(pad, toY(0));
      ctx.lineTo(W - pad, toY(0));
      ctx.stroke();
      
      // L2 circle
      if (betaRidge) {
        const r2 = Math.sqrt(betaRidge[0]**2 + betaRidge[1]**2);
        ctx.strokeStyle = '#a78bfa';
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        for (let t = 0; t <= 100; t++) {
          const angle = t / 100 * Math.PI * 2;
          const a = r2 * Math.cos(angle);
          const b = r2 * Math.sin(angle);
          const px = toX(a), py = toY(b);
          if (t === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.stroke();
      }
      
      // L1 diamond
      if (betaLasso) {
        const r1 = Math.abs(betaLasso[0]) + Math.abs(betaLasso[1]);
        ctx.strokeStyle = '#fcd34d';
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.moveTo(toX(r1), toY(0));
        ctx.lineTo(toX(0), toY(r1));
        ctx.lineTo(toX(-r1), toY(0));
        ctx.lineTo(toX(0), toY(-r1));
        ctx.closePath();
        ctx.stroke();
      }
      
      // Points
      // OLS
      ctx.fillStyle = '#4ade80';
      ctx.beginPath();
      ctx.arc(toX(aOLS), toY(bOLS), 7, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1.5;
      ctx.stroke();
      
      // Ridge
      if (betaRidge) {
        ctx.fillStyle = '#a78bfa';
        ctx.beginPath();
        ctx.arc(toX(betaRidge[0]), toY(betaRidge[1]), 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
      }
      
      // Lasso
      if (betaLasso) {
        ctx.fillStyle = '#fcd34d';
        ctx.beginPath();
        ctx.arc(toX(betaLasso[0]), toY(betaLasso[1]), 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
      }
      
      // Labels
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.font = '11px system-ui';
      ctx.fillText('a (x¬≤ coef)', W - pad - 60, H - pad + 15);
      ctx.save();
      ctx.translate(12, H/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText('b (x coef)', 0, 0);
      ctx.restore();
      
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.font = '10px monospace';
      ctx.fillText(`c fixed = ${cFix.toFixed(4)}`, pad + 5, H - pad + 15);
      ctx.fillText(`Œª = ${lambda.toFixed(2)}`, W - pad - 50, pad + 15);
    }
    
    // ==================== UI UPDATES ====================
    const betaOLS = olsSolve();
    
    function populateDataTable() {
      const tbody = document.querySelector('#dataTable tbody');
      tbody.innerHTML = data.map((d, i) => 
        `<tr><td>${i+1}</td><td class="mono">${fmt(d[0])}</td><td class="mono">${fmt(d[1])}</td></tr>`
      ).join('');
    }
    
    function populateDesignMatrix() {
      const tbody = document.querySelector('#designMatrix tbody');
      tbody.innerHTML = X.map((row, i) => 
        `<tr><td>${i+1}</td><td>${fmt(row[0])}</td><td>${fmt(row[1])}</td><td>${fmt(row[2], 0)}</td></tr>`
      ).join('');
      
      const yTbody = document.querySelector('#yVector tbody');
      yTbody.innerHTML = y.map((v, i) => 
        `<tr><td>${i+1}</td><td>${fmt(v)}</td></tr>`
      ).join('');
    }
    
    function updateXtXDisplay() {
      const el = document.getElementById('xtxMatrix');
      el.textContent = XtX.map(row => row.map(v => fmt(v, 2)).join('  ')).join('\n');
    }
    
    function updateEigenDisplay() {
      const H = XtX.map(row => row.map(v => 2 * v / n));
      // Diagonal as rough eigenvalue estimates
      const diag = [H[0][0], H[1][1], H[2][2]];
      diag.sort((a, b) => b - a);
      
      document.getElementById('eigenvalues').textContent = 
        `Œª‚ÇÅ ‚âà ${fmt(diag[0], 4)}\nŒª‚ÇÇ ‚âà ${fmt(diag[1], 4)}\nŒª‚ÇÉ ‚âà ${fmt(diag[2], 4)}`;
      
      const kappa = diag[0] / Math.max(diag[2], 0.001);
      document.getElementById('conditionNum').textContent = 
        `Œ∫ = Œª_max / Œª_min ‚âà ${fmt(kappa, 2)}${kappa > 10 ? ' (ill-conditioned!)' : ''}`;
    }
    
    function updateOLSDisplay() {
      document.getElementById('olsSolution').textContent = 
        `a = ${fmt(betaOLS[0], 6)}\nb = ${fmt(betaOLS[1], 6)}\nc = ${fmt(betaOLS[2], 6)}`;
      
      document.getElementById('olsEquation').innerHTML = 
        `≈∑ = <span class="hl-accent">${fmt(betaOLS[0])}</span>x¬≤ + <span class="hl-accent">${fmt(betaOLS[1])}</span>x + <span class="hl-accent">${fmt(betaOLS[2])}</span>`;
      
      document.getElementById('olsMSE').textContent = fmt(mse(betaOLS), 6);
      document.getElementById('olsA').textContent = fmt(betaOLS[0], 4);
      document.getElementById('olsB').textContent = fmt(betaOLS[1], 4);
      
      drawScatter('cvStep4', betaOLS, { color: '#4ade80' });
    }
    
    function updateRidgeDisplay() {
      const lambda = parseFloat(document.getElementById('ridgeLambda').value);
      document.getElementById('ridgeLambdaVal').textContent = fmt(lambda, 2);
      
      const beta = ridgeSolve(lambda, false);
      
      document.getElementById('ridgeSolution').textContent = 
        `a = ${fmt(beta[0], 6)}\nb = ${fmt(beta[1], 6)}\nc = ${fmt(beta[2], 6)}`;
      
      document.getElementById('ridgeMSE').textContent = fmt(mse(beta), 6);
      document.getElementById('ridgePen').textContent = fmt(l2Penalty(beta), 6);
      document.getElementById('ridgeJ').textContent = fmt(objective('ridge', beta, lambda), 6);
      
      drawScatter('cvStep5', beta, { color: '#a78bfa' });
      
      // Update CV plot if we have results
      if (ridgeOptimalResult) {
        drawRidgeCVPlot(ridgeOptimalResult.results, lambda);
        drawRidgeCoefficientPath(ridgeOptimalResult.results, lambda, ridgeOptimalResult.bestLambda);
      }
    }
    
    // Initialize Ridge CV on load
    function initRidgeCV() {
      ridgeOptimalResult = findOptimalRidgeLambda(false);
      const currentLambda = parseFloat(document.getElementById('ridgeLambda').value);
      drawRidgeCVPlot(ridgeOptimalResult.results, currentLambda);
      populateRidgeCVTable(ridgeOptimalResult.results);
      drawRidgeCoefficientPath(ridgeOptimalResult.results, currentLambda, ridgeOptimalResult.bestLambda);
      
      // Show optimal lambda in result box
      const resultEl = document.getElementById('ridgeOptimalResult');
      resultEl.style.display = 'block';
      document.getElementById('ridgeOptimalText').innerHTML = 
        `<strong class="hl-green">Optimal Œª by LOOCV:</strong><br>` +
        `Œª* = <strong>${ridgeOptimalResult.bestLambda.toFixed(4)}</strong><br>` +
        `CV Error = ${ridgeOptimalResult.bestCV.toFixed(6)}`;
    }
    
    function updateLassoDisplay() {
      const lambda = parseFloat(document.getElementById('lassoLambda').value);
      document.getElementById('lassoLambdaVal').textContent = fmt(lambda, 2);
      
      const beta = lassoState.beta;
      
      document.getElementById('lassoSolution').textContent = 
        `a = ${fmt(beta[0], 6)}${Math.abs(beta[0]) < 0.0001 ? ' ‚Üê ZERO!' : ''}\nb = ${fmt(beta[1], 6)}${Math.abs(beta[1]) < 0.0001 ? ' ‚Üê ZERO!' : ''}\nc = ${fmt(beta[2], 6)}`;
      
      document.getElementById('lassoMSE').textContent = fmt(mse(beta), 6);
      document.getElementById('lassoPen').textContent = fmt(l1Penalty(beta), 6);
      
      const zeros = (Math.abs(beta[0]) < 0.0001 ? 1 : 0) + (Math.abs(beta[1]) < 0.0001 ? 1 : 0);
      document.getElementById('lassoZeros').textContent = zeros > 0 ? `Yes (${zeros})` : 'No';
      
      drawScatter('cvStep6', beta, { color: '#fcd34d' });
      
      // Update convergence status
      const statusEl = document.getElementById('convergenceStatus');
      const textEl = document.getElementById('convergenceText');
      if (lassoState.step === 0) {
        statusEl.style.borderColor = 'var(--line)';
        statusEl.style.background = 'rgba(255,255,255,0.05)';
        textEl.innerHTML = '‚è∏Ô∏è <strong>Not started</strong> ‚Äî Click buttons to run coordinate descent';
      } else if (lassoState.converged) {
        statusEl.style.borderColor = 'var(--green)';
        statusEl.style.background = 'rgba(74,222,128,0.15)';
        textEl.innerHTML = `‚úÖ <strong>CONVERGED!</strong> at step ${lassoState.step} ‚Äî |ŒîJ| < ${lassoState.convergenceThreshold} (objective stopped changing)`;
      } else {
        const lastLog = lassoState.log[lassoState.log.length - 1];
        if (lastLog && lastLog.deltaJ !== null) {
          const absŒîJ = Math.abs(lastLog.deltaJ);
          const progress = Math.min(100, Math.max(0, 100 - Math.log10(absŒîJ + 1e-10) * 15));
          statusEl.style.borderColor = 'var(--l1)';
          statusEl.style.background = 'rgba(252,211,77,0.1)';
          textEl.innerHTML = `üîÑ <strong>Iterating...</strong> Step ${lassoState.step} | |ŒîJ| = ${absŒîJ.toExponential(2)} | Progress: ~${progress.toFixed(0)}%`;
        } else {
          statusEl.style.borderColor = 'var(--l1)';
          statusEl.style.background = 'rgba(252,211,77,0.1)';
          textEl.innerHTML = `üîÑ <strong>Iterating...</strong> Step ${lassoState.step}`;
        }
      }
      
      // Update log table with ŒîJ column
      const tbody = document.querySelector('#lassoLog tbody');
      tbody.innerHTML = lassoState.log.slice(-20).map(l => {
        let statusClass = '';
        let statusIcon = '';
        if (l.status === 'converged') {
          statusClass = 'hl-green';
          statusIcon = '‚úÖ';
        } else if (l.status === 'increased!') {
          statusClass = 'hl-red';
          statusIcon = '‚ö†Ô∏è';
        } else if (l.status === 'decreasing') {
          statusClass = 'hl-accent';
          statusIcon = '‚Üì';
        }
        
        const deltaJStr = l.deltaJ !== null ? l.deltaJ.toExponential(2) : '‚Äî';
        const betaHighlight = Math.abs(l.newBeta) < 0.0001 ? 'hl-l1' : '';
        
        return `<tr>
          <td>${l.step}</td>
          <td>${l.param}</td>
          <td class="mono">${fmt(l.rho, 4)}</td>
          <td class="mono ${betaHighlight}">${fmt(l.newBeta, 6)}</td>
          <td class="mono">${fmt(l.J, 6)}</td>
          <td class="mono">${deltaJStr}</td>
          <td class="${statusClass}">${statusIcon} ${l.status}</td>
        </tr>`;
      }).join('');
      
      // Auto-scroll to bottom of log
      const logWrap = document.querySelector('#lassoLog').closest('.log-wrap');
      if (logWrap) logWrap.scrollTop = logWrap.scrollHeight;
    }
    
    function updatePlayground() {
      const lambda = parseFloat(document.getElementById('playLambda').value);
      const penInt = document.getElementById('playPenInt').value === 'yes';
      document.getElementById('playLambdaVal').textContent = fmt(lambda, 2);
      
      const betaRidge = ridgeSolve(lambda, penInt);
      
      // Run lasso fresh
      lassoInit();
      const lassoLambda = lambda;
      for (let i = 0; i < 30; i++) {
        lassoSweep(lassoLambda, penInt);
      }
      const betaLasso = lassoState.beta.slice();
      
      // Draw curves
      drawScatter('cvPlayData', null, {
        curves: [
          { beta: betaOLS, color: '#4ade80' },
          { beta: betaRidge, color: '#a78bfa' },
          { beta: betaLasso, color: '#fcd34d' }
        ]
      });
      
      // Draw geometry
      drawGeometry('cvPlayGeom', betaOLS, betaRidge, betaLasso, lambda, penInt);
      
      // Update cards
      document.getElementById('playOLS').innerHTML = 
        `a = ${fmt(betaOLS[0], 4)}<br>b = ${fmt(betaOLS[1], 4)}<br>c = ${fmt(betaOLS[2], 4)}<br><br>MSE = ${fmt(mse(betaOLS), 4)}`;
      
      document.getElementById('playRidge').innerHTML = 
        `a = ${fmt(betaRidge[0], 4)}<br>b = ${fmt(betaRidge[1], 4)}<br>c = ${fmt(betaRidge[2], 4)}<br><br>MSE = ${fmt(mse(betaRidge), 4)}<br>J = ${fmt(objective('ridge', betaRidge, lambda, penInt), 4)}`;
      
      const lassoZeros = (Math.abs(betaLasso[0]) < 0.0001 ? 1 : 0) + (Math.abs(betaLasso[1]) < 0.0001 ? 1 : 0);
      document.getElementById('playLasso').innerHTML = 
        `a = ${fmt(betaLasso[0], 4)}<br>b = ${fmt(betaLasso[1], 4)}<br>c = ${fmt(betaLasso[2], 4)}<br><br>MSE = ${fmt(mse(betaLasso), 4)}<br>J = ${fmt(objective('lasso', betaLasso, lambda, penInt), 4)}<br>Zeros: ${lassoZeros}`;
    }
    
    // ==================== EVENT LISTENERS ====================
    document.getElementById('ridgeLambda').addEventListener('input', updateRidgeDisplay);
    
    document.getElementById('ridgeFindOptimal').addEventListener('click', () => {
      ridgeOptimalResult = findOptimalRidgeLambda(false);
      drawRidgeCVPlot(ridgeOptimalResult.results, parseFloat(document.getElementById('ridgeLambda').value));
      populateRidgeCVTable(ridgeOptimalResult.results);
      
      // Show result
      const resultEl = document.getElementById('ridgeOptimalResult');
      resultEl.style.display = 'block';
      document.getElementById('ridgeOptimalText').innerHTML = 
        `<strong class="hl-green">‚úì Optimal Œª found!</strong><br>` +
        `Œª* = <strong>${ridgeOptimalResult.bestLambda.toFixed(4)}</strong><br>` +
        `CV Error = ${ridgeOptimalResult.bestCV.toFixed(6)}<br>` +
        `<span class="tiny">Click "Apply Optimal Œª" to use this value</span>`;
    });
    
    document.getElementById('ridgeApplyOptimal').addEventListener('click', () => {
      if (ridgeOptimalResult) {
        const slider = document.getElementById('ridgeLambda');
        // Clamp to slider range
        const optLam = Math.min(3, Math.max(0, ridgeOptimalResult.bestLambda));
        slider.value = optLam;
        updateRidgeDisplay();
      }
    });
    
    // Lasso CV event listeners
    document.getElementById('lassoFindOptimal').addEventListener('click', () => {
      lassoOptimalResult = findOptimalLassoLambda(false);
      drawLassoCVPlot(lassoOptimalResult.results, parseFloat(document.getElementById('lassoLambda').value));
      populateLassoCVTable(lassoOptimalResult.results);
      
      // Show result
      const resultEl = document.getElementById('lassoOptimalResult');
      resultEl.style.display = 'block';
      const bestBeta = lassoOptimalResult.results.find(r => r.isBest).beta;
      const zeros = (Math.abs(bestBeta[0]) < 0.0001 ? 1 : 0) + (Math.abs(bestBeta[1]) < 0.0001 ? 1 : 0);
      document.getElementById('lassoOptimalText').innerHTML = 
        `<strong class="hl-green">‚úì Optimal Œª found!</strong><br>` +
        `Œª* = <strong>${lassoOptimalResult.bestLambda.toFixed(4)}</strong><br>` +
        `CV Error = ${lassoOptimalResult.bestCV.toFixed(6)}<br>` +
        `Zeros at optimal: ${zeros}<br>` +
        `<span class="tiny">Click "Apply Optimal Œª" to use this value</span>`;
    });
    
    document.getElementById('lassoApplyOptimal').addEventListener('click', () => {
      if (lassoOptimalResult) {
        const slider = document.getElementById('lassoLambda');
        const optLam = Math.min(3, Math.max(0, lassoOptimalResult.bestLambda));
        slider.value = optLam;
        lassoInit();
        lassoFull(optLam, false);
        updateLassoDisplay();
      }
    });
    
    // Initialize Lasso CV plot on load
    function initLassoCV() {
      lassoOptimalResult = findOptimalLassoLambda(false);
      const currentLambda = parseFloat(document.getElementById('lassoLambda').value);
      drawLassoCVPlot(lassoOptimalResult.results, currentLambda);
      populateLassoCVTable(lassoOptimalResult.results);
    }
    
    document.getElementById('lassoLambda').addEventListener('input', () => {
      // Don't reset state, just update display
      updateLassoDisplay();
    });
    
    document.getElementById('lassoStep').addEventListener('click', () => {
      const lambda = parseFloat(document.getElementById('lassoLambda').value);
      lassoOneStep(lambda, false);
      updateLassoDisplay();
    });
    
    document.getElementById('lassoSweep').addEventListener('click', () => {
      const lambda = parseFloat(document.getElementById('lassoLambda').value);
      lassoSweep(lambda, false);
      updateLassoDisplay();
    });
    
    document.getElementById('lassoFull').addEventListener('click', () => {
      const lambda = parseFloat(document.getElementById('lassoLambda').value);
      lassoFull(lambda, false);
      updateLassoDisplay();
    });
    
    document.getElementById('lassoConverge').addEventListener('click', () => {
      const lambda = parseFloat(document.getElementById('lassoLambda').value);
      let maxIter = 500; // Safety limit
      let iter = 0;
      
      while (!lassoState.converged && iter < maxIter) {
        lassoOneStep(lambda, false);
        iter++;
      }
      
      updateLassoDisplay();
      
      if (lassoState.converged) {
        // Flash the status to draw attention
        const statusEl = document.getElementById('convergenceStatus');
        statusEl.style.transition = 'transform 0.1s';
        statusEl.style.transform = 'scale(1.02)';
        setTimeout(() => { statusEl.style.transform = 'scale(1)'; }, 100);
      }
    });
    
    document.getElementById('lassoReset').addEventListener('click', () => {
      lassoInit();
      document.querySelector('#lassoLog tbody').innerHTML = '';
      // Reset convergence status display
      const statusEl = document.getElementById('convergenceStatus');
      statusEl.style.borderColor = 'var(--line)';
      statusEl.style.background = 'rgba(255,255,255,0.05)';
      document.getElementById('convergenceText').innerHTML = '‚è∏Ô∏è <strong>Not started</strong> ‚Äî Click buttons to run coordinate descent';
      updateLassoDisplay();
    });
    
    document.getElementById('playLambda').addEventListener('input', updatePlayground);
    document.getElementById('playPenInt').addEventListener('change', updatePlayground);
    
    // Smooth scroll
    document.querySelectorAll('nav a').forEach(link => {
      link.addEventListener('click', e => {
        e.preventDefault();
        const target = document.querySelector(link.getAttribute('href'));
        if (target) target.scrollIntoView({ behavior: 'smooth' });
      });
    });
    
    // ==================== INIT ====================
    function init() {
      populateDataTable();
      populateDesignMatrix();
      updateXtXDisplay();
      updateEigenDisplay();
      updateOLSDisplay();
      
      // Initialize Ridge with CV
      initRidgeCV();
      updateRidgeDisplay();
      
      // Initialize Lasso
      lassoInit();
      updateLassoDisplay();
      
      // Initialize Lasso CV
      initLassoCV();
      
      drawScatter('cvStep1');
      
      updatePlayground();
    }
    
    init();
  </script>
</body>
</html>